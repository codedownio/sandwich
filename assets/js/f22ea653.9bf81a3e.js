"use strict";(self.webpackChunksandwich_site=self.webpackChunksandwich_site||[]).push([[1473],{1544:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>i,metadata:()=>a,toc:()=>d});var n=s(6070),o=s(6113);const i={id:"sandwich-contexts-postgresql",title:"PostgreSQL"},r=void 0,a={id:"context-libraries/sandwich-contexts-postgresql",title:"PostgreSQL",description:"The Test.Sandwich.Contexts.PostgreSQL module provides tools for introducing PostgreSQL databases, either via a container (Docker or Podman) or via a raw process (typically obtaining the binary from Nix).",source:"@site/docs/context-libraries/sandwich-contexts-postgresql.md",sourceDirName:"context-libraries",slug:"/context-libraries/sandwich-contexts-postgresql",permalink:"/sandwich/docs/context-libraries/sandwich-contexts-postgresql",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/edit/master/website/docs/context-libraries/sandwich-contexts-postgresql.md",tags:[],version:"current",frontMatter:{id:"sandwich-contexts-postgresql",title:"PostgreSQL"},sidebar:"docs",previous:{title:"Base contexts",permalink:"/sandwich/docs/context-libraries/sandwich-contexts"},next:{title:"SMTP",permalink:"/sandwich/docs/context-libraries/sandwich-contexts-smtp"}},c={},d=[{value:"Raw binary via Nix",id:"raw-binary-via-nix",level:2},{value:"Container",id:"container",level:2},{value:"About the use of Unix sockets",id:"about-the-use-of-unix-sockets",level:2}];function l(e){const t={a:"a",code:"code",h2:"h2",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(t.p,{children:["The ",(0,n.jsx)(t.a,{href:"https://hackage.haskell.org/package/sandwich-contexts/docs/Test-Sandwich-Contexts-PostgreSQL.html",children:"Test.Sandwich.Contexts.PostgreSQL"})," module provides tools for introducing PostgreSQL databases, either via a container (Docker or Podman) or via a raw process (typically obtaining the binary from Nix)."]}),"\n",(0,n.jsx)(t.p,{children:"The container method is traditional, but the raw method can be nice because it tends to leave less junk on the system such as container images, networks, and volumes."}),"\n",(0,n.jsxs)(t.p,{children:["This module is currently included in ",(0,n.jsx)(t.a,{href:"./sandwich-contexts",children:"sandwich-contexts"}),", but may be split into its own package in the future."]}),"\n",(0,n.jsx)(t.h2,{id:"raw-binary-via-nix",children:"Raw binary via Nix"}),"\n",(0,n.jsxs)(t.p,{children:["Here's an example of using a PostgreSQL server using a ",(0,n.jsx)(t.a,{href:"./sandwich-contexts#nix-contexts",children:"NixContext"})," and ",(0,n.jsx)(t.a,{href:"https://hackage.haskell.org/package/sandwich-contexts/docs/Test-Sandwich-Contexts-PostgreSQL.html#v:introducePostgresViaNix",children:"introducePostgresViaNix"}),"."]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-haskell",metastring:'title="https://github.com/codedownio/sandwich/blob/master/demos/demo-postgres/app/Main.hs"',children:'import Database.PostgreSQL.Simple (Only(..), connectPostgreSQL, query_)\nimport Test.Sandwich.Contexts.PostgreSQL\n\nspec :: TopSpec\nspec = describe "Introducing PostgreSQL via Nix" $ do\n  introduceNixContext nixpkgsReleaseDefault $ introducePostgresViaNix defaultPostgresNixOptions $ do\n    it "runs a simple query" $ do\n      PostgresContext {..} <- getContext postgres\n      conn <- connectPostgreSQL connString\n      [Only n] <- query_ conn "select 2 + 2"\n      n `shouldBe` 4\n'})}),"\n",(0,n.jsx)(t.h2,{id:"container",children:"Container"}),"\n",(0,n.jsxs)(t.p,{children:["Here's an example of using a container via ",(0,n.jsx)(t.a,{href:"https://hackage.haskell.org/package/sandwich-contexts/docs/Test-Sandwich-Contexts-PostgreSQL.html#v:introducePostgresViaContainer",children:"introducePostgresViaContainer"}),". You can configure the container options using ",(0,n.jsx)(t.a,{href:"https://hackage.haskell.org/package/sandwich-contexts/docs/Test-Sandwich-Contexts-PostgreSQL.html#t:PostgresContainerOptions",children:"PostgresContainerOptions"}),"."]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-haskell",metastring:'title="https://github.com/codedownio/sandwich/blob/master/demos/demo-postgres/app/Main.hs"',children:'import Database.PostgreSQL.Simple (Only(..), connectPostgreSQL, query_)\nimport Test.Sandwich.Contexts.PostgreSQL\n\nspec :: TopSpec\nspec = describe "Introducing PostgreSQL via container" $ do\n  introducePostgresViaContainer defaultPostgresContainerOptions $ do\n    it "runs a simple query" $ do\n      PostgresContext {..} <- getContext postgres\n      conn <- connectPostgreSQL connString\n      [Only n] <- query_ conn "select 2 + 2"\n      n `shouldBe` 4\n'})}),"\n",(0,n.jsx)(t.h2,{id:"about-the-use-of-unix-sockets",children:"About the use of Unix sockets"}),"\n",(0,n.jsx)(t.p,{children:"Starting a Postgres process on a randomly chosen port is tricky, because Postgres currently lacks a setting for choosing its own port and reporting it back to us. So, the only way to start it on a random TCP port is to first manually find a free port on the system and then start Postgres with it. Since this procedure is inherently racy, it can cause failures if your tests are starting lots of Postgres instances (or other network-using processes) in parallel."}),"\n",(0,n.jsxs)(t.p,{children:["This module takes a different approach: it starts the Postgres instance on a Unix socket, which can never fail. You can connect to it via the Unix socket directly if you like. If you use the TCP-based methods like ",(0,n.jsx)(t.code,{children:"introducePostgresViaNix"}),", they will open a TCP socket inside the test process and then run a proxy to forward packets to the Postgres server's Unix socket."]})]})}function h(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(l,{...e})}):l(e)}},6113:(e,t,s)=>{s.d(t,{R:()=>r,x:()=>a});var n=s(758);const o={},i=n.createContext(o);function r(e){const t=n.useContext(i);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),n.createElement(i.Provider,{value:t},e.children)}}}]);