"use strict";(self.webpackChunksandwich_site=self.webpackChunksandwich_site||[]).push([[8041],{7843:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>i,default:()=>h,frontMatter:()=>o,metadata:()=>r,toc:()=>c});var s=n(6070),a=n(6113);n(4125);const o={id:"contexts",title:"Contexts",sidebar_label:"Contexts",slug:"/contexts"},i=void 0,r={id:"contexts",title:"Contexts",description:"One of Sandwich's most powerful features is the ability to introduce contexts in tests. A context is simply a labeled dependency, which can be obtained in a test using the getContext function:",source:"@site/docs/contexts.md",sourceDirName:".",slug:"/contexts",permalink:"/sandwich/docs/contexts",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/edit/master/website/docs/contexts.md",tags:[],version:"current",frontMatter:{id:"contexts",title:"Contexts",sidebar_label:"Contexts",slug:"/contexts"},sidebar:"docs",previous:{title:"Introduction",permalink:"/sandwich/docs/"},next:{title:"Node Options",permalink:"/sandwich/docs/node_options"}},d={},c=[{value:"Built-in contexts",id:"built-in-contexts",level:2},{value:"Introducing your own contexts",id:"introducing-your-own-contexts",level:2},{value:"The HasX pattern for context dependencies",id:"the-hasx-pattern-for-context-dependencies",level:2},{value:"Contexts depending on other contexts",id:"contexts-depending-on-other-contexts",level:2}];function l(e){const t={a:"a",code:"code",em:"em",h2:"h2",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(t.p,{children:["One of Sandwich's most powerful features is the ability to introduce ",(0,s.jsx)(t.em,{children:"contexts"})," in tests. A context is simply a labeled dependency, which can be obtained in a test using the ",(0,s.jsx)(t.code,{children:"getContext"})," function:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-haskell",children:'it "tests the database" $ do\n  db <- getContext database\n  queryUser db "user1" >>= (`shouldBe` mockUser1)\n'})}),"\n",(0,s.jsx)(t.p,{children:"Sandwich gives you the tools to introduce (and gracefully tear down) contexts for use in your tests while keeping the plumbing nicely hidden.  The type system enforces that a test has all the contexts it needs."}),"\n",(0,s.jsx)(t.h2,{id:"built-in-contexts",children:"Built-in contexts"}),"\n",(0,s.jsxs)(t.p,{children:["Sandwich provides some contexts automatically. For example, you can retrieve the on-disk folder for a given node by calling ",(0,s.jsx)(t.code,{children:"getCurrentFolder"}),". This can be useful if you want to save custom logs, screenshots, etc. to the folder."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-haskell",children:'it "saves a picture of the login page using Selenium" $ do\n  openPage "/login"\n  Just folder <- getCurrentFolder\n  screenshot >>= B.writeFile (folder </> "screenshot.png")\n'})}),"\n",(0,s.jsxs)(t.p,{children:["Note that ",(0,s.jsx)(t.code,{children:"getCurrentFolder"})," returns a ",(0,s.jsx)(t.code,{children:"Maybe FilePath"}),". It will be ",(0,s.jsx)(t.code,{children:"Nothing"})," if your tests are run without an on-disk folder, or if the particular node in question is configured not to create a folder in its ",(0,s.jsx)(t.a,{href:"http://localhost:3000/docs/node_options",children:"node options"}),"."]}),"\n",(0,s.jsxs)(t.p,{children:["Another built-in function is ",(0,s.jsx)(t.code,{children:"getRunRoot"}),", which will return the ",(0,s.jsx)(t.em,{children:"root"})," of the on-disk test tree. This can be useful if you want to store test-wide artifacts there. Similar caveats apply when Sandwich is configured to run without on-disk state."]}),"\n",(0,s.jsx)(t.h2,{id:"introducing-your-own-contexts",children:"Introducing your own contexts"}),"\n",(0,s.jsxs)(t.p,{children:["Suppose we want to introduce a mock database into some tests. First, we define a label for it. The label represents the mapping between a type-level string and the type of the context. You can find the full working example for this section ",(0,s.jsx)(t.a,{href:"https://github.com/codedownio/sandwich/blob/master/demos/demo-contexts/app/Main.hs",children:"here"}),"."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-haskell",children:'{-# LANGUAGE DataKinds #-}\n\ndata DatabaseContext = MySQLDatabaseContext | SqliteDatabaseContext\n  deriving Show\n\ndatabase = Label :: Label "database" DatabaseContext\n'})}),"\n",(0,s.jsxs)(t.p,{children:["Next, we write the introduce node. We choose to use ",(0,s.jsx)(t.a,{href:"http://hackage.haskell.org/package/sandwich/docs/Test-Sandwich.html#v:introduceWith",children:"introduceWith"}),", because it allows us to use the ",(0,s.jsx)(t.code,{children:"bracket"})," pattern to create and then tear down our database. You can imagine IO actions happening here."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-haskell",children:'introduceDatabase = introduceWith "Introduce database" database $ \\action ->\n  bracket (debug "Spinning up DB..." >> return MySQLDatabaseContext)\n          (\\db -> debug "Tearing down DB..." >> return ())\n          (void . action)\n'})}),"\n",(0,s.jsxs)(t.p,{children:["Inside the test, we can use ",(0,s.jsx)(t.code,{children:"getContext"})," to get the context and do things with it."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-haskell",children:'contextsDemo :: TopSpec\ncontextsDemo = describe "Contexts" $ do\n  introduceDatabase $ do\n    it "Uses the database" $ do\n      db <- getContext database\n      info [i|Got database: \'#{db}\'|]\n'})}),"\n",(0,s.jsx)(t.h2,{id:"the-hasx-pattern-for-context-dependencies",children:"The HasX pattern for context dependencies"}),"\n",(0,s.jsxs)(t.p,{children:["Now let's decouple the introduce node from the test (full working example ",(0,s.jsx)(t.a,{href:"https://github.com/codedownio/sandwich/blob/master/demos/demo-context-dependencies/app/Main.hs",children:"here"}),"). First, we'll define the type of a spec that depends on a database. To do this, we'll need a HasX-style constraint type."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-haskell",children:'{-# LANGUAGE ConstraintKinds #-}\n{-# LANGUAGE DataKinds #-}\ntype HasDatabase context = HasLabel context "database" DatabaseContext\n'})}),"\n",(0,s.jsx)(t.p,{children:"Now, we can use this to define the type of our spec."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-haskell",children:"{-# LANGUAGE RankNTypes #-}\ntype DatabaseSpec = forall context. (HasDatabase context) => SpecFree context IO ()\n"})}),"\n",(0,s.jsxs)(t.p,{children:["Now that we have the spec type, we can start writing specs. You can imagine these living in separate files. These tests don't care about the exact context they're run with, as long as it has a ",(0,s.jsx)(t.code,{children:"database"})," available."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-haskell",children:"-- In DatabaseTest1.hs\ndatabaseTest1 :: DatabaseSpec\ndatabaseTest1 = do\n  it \"uses the database 1\" $ getContext database >>= \\db ->\n    info [i|Got database: '#{db}'|]\n\n-- In DatabaseTest2.hs\ndatabaseTest2 :: DatabaseSpec\ndatabaseTest2 = do\n  it \"uses the database 2\" $ getContext database >>= \\db ->\n    info [i|Got database: '#{db}'|]\n"})}),"\n",(0,s.jsx)(t.p,{children:"Now, in your main test file, you can import both of these tests and run them in the same test tree."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-haskell",children:'contextDepsDemo :: TopSpec\ncontextDepsDemo = describe "Context dependencies" $ do\n  introduceDatabase $ do\n    databaseTest1\n    databaseTest2\n'})}),"\n",(0,s.jsx)(t.p,{children:"Or, if you want better isolation, you can rearrange this to create a separate database for each subtree."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-haskell",children:'contextDepsDemo :: TopSpec\ncontextDepsDemo = describe "Context dependencies" $ do\n  introduceDatabase databaseTest1\n  introduceDatabase databaseTest2\n'})}),"\n",(0,s.jsx)(t.p,{children:"Either way, the type system ensures that your tests have the contexts they need."}),"\n",(0,s.jsx)(t.h2,{id:"contexts-depending-on-other-contexts",children:"Contexts depending on other contexts"}),"\n",(0,s.jsx)(t.p,{children:"We can use the same HasX trick to write contexts that depend on other contexts. For example, suppose you're testing a server and the server depends on a database. You need a database to exist first in order to create the server, and you want both the server and the database available to your tests."}),"\n",(0,s.jsxs)(t.p,{children:["First, let's introduce the ",(0,s.jsx)(t.code,{children:"Server"})," type and an introduce function for it. This introduce function is special because it contains a ",(0,s.jsx)(t.code,{children:"getContext"})," call to retrieve the database and use it to make the server."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-haskell",children:'data Server = Server DatabaseContext deriving Show\nserver = Label :: Label "server" Server\n\nintroduceServer = introduceWith "Introduce server" server $ \\action -> do\n  bracket (do\n              db <- getContext database\n              debug "Spinning up server..."\n              return $ Server db\n          )\n          (\\server -> debug "Tearing down server..." >> return ())\n          (void . action)\n'})}),"\n",(0,s.jsxs)(t.p,{children:["Now, we need to write ",(0,s.jsx)(t.code,{children:"introduceServer"})," nested inside a ",(0,s.jsx)(t.code,{children:"introduceDatabase"})," node:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-haskell",children:'contextNestedDepsDemo :: TopSpec\ncontextNestedDepsDemo = describe "Nested dependencies" $ do\n  introduceDatabase $\n    introduceServer $\n      it "uses the server" $ do\n        s <- getContext server\n        debug [i|Got server: #{s}|]\n'})}),"\n",(0,s.jsxs)(t.p,{children:["Note that it's usually easiest to let GHC infer the type signature of ",(0,s.jsx)(t.code,{children:"introduceServer"}),". If you do need to write out the type signature, it can be a little bit verbose since it needs to use the underlying context constructors and put appropriate constraints on the base monad. For this example, the signature for this example might look like this:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-haskell",children:'introduceServer :: (HasDatabase context, MonadIO m)\n  => SpecFree (LabelValue "server" Server :> context) m () -> SpecFree context m ()\n'})}),"\n",(0,s.jsxs)(t.p,{children:["The full code for this example can be found ",(0,s.jsx)(t.a,{href:"https://github.com/codedownio/sandwich/blob/master/demos/demo-context-nested/app/Main.hs",children:"here"}),"."]})]})}function h(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},6113:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>r});var s=n(758);const a={},o=s.createContext(a);function i(e){const t=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),s.createElement(o.Provider,{value:t},e.children)}}}]);