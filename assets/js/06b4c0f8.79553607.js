"use strict";(self.webpackChunksandwich_site=self.webpackChunksandwich_site||[]).push([[4160],{1806:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>u,frontMatter:()=>r,metadata:()=>o,toc:()=>l});var t=s(6070),i=s(6113);const r={id:"sandwich-contexts-kubernetes",title:"Kubernetes"},a=void 0,o={id:"context-libraries/sandwich-contexts-kubernetes",title:"Kubernetes",description:"The sandwich-contexts-kubernetes package provides contexts for creating and managing Kubernetes clusters in your tests, along with utilities for interacting with them.",source:"@site/docs/context-libraries/sandwich-contexts-kubernetes.md",sourceDirName:"context-libraries",slug:"/context-libraries/sandwich-contexts-kubernetes",permalink:"/sandwich/docs/context-libraries/sandwich-contexts-kubernetes",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/edit/master/website/docs/context-libraries/sandwich-contexts-kubernetes.md",tags:[],version:"current",frontMatter:{id:"sandwich-contexts-kubernetes",title:"Kubernetes"},sidebar:"docs",previous:{title:"SMTP",permalink:"/sandwich/docs/context-libraries/sandwich-contexts-smtp"},next:{title:"MinIO",permalink:"/sandwich/docs/context-libraries/sandwich-contexts-minio"}},c={},l=[{value:"Creating clusters",id:"creating-clusters",level:2},{value:"Kind clusters",id:"kind-clusters",level:3},{value:"Minikube clusters",id:"minikube-clusters",level:3},{value:"Working with clusters",id:"working-with-clusters",level:2},{value:"Running kubectl commands",id:"running-kubectl-commands",level:3},{value:"Waiting for resources",id:"waiting-for-resources",level:3},{value:"Image management",id:"image-management",level:2},{value:"Loading images",id:"loading-images",level:3},{value:"Checking loaded images",id:"checking-loaded-images",level:3},{value:"Service forwarding and port forwarding",id:"service-forwarding-and-port-forwarding",level:2},{value:"Service forwarding",id:"service-forwarding",level:3},{value:"Port forwarding",id:"port-forwarding",level:3},{value:"Namespaces",id:"namespaces",level:2},{value:"MinIO integration",id:"minio-integration",level:2},{value:"Logging",id:"logging",level:2}];function d(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.a,{href:"https://hackage.haskell.org/package/sandwich-contexts-kubernetes",children:"sandwich-contexts-kubernetes"})," package provides contexts for creating and managing Kubernetes clusters in your tests, along with utilities for interacting with them."]}),"\n",(0,t.jsxs)(n.p,{children:["This package supports creating clusters using either ",(0,t.jsx)(n.a,{href:"https://kind.sigs.k8s.io/",children:"kind"})," or ",(0,t.jsx)(n.a,{href:"https://minikube.sigs.k8s.io",children:"Minikube"}),", with binaries obtained either from the system PATH or from Nix. It also includes functions for waiting for pods and services, running kubectl commands, service forwarding, port forwarding, and image management."]}),"\n",(0,t.jsx)(n.h2,{id:"creating-clusters",children:"Creating clusters"}),"\n",(0,t.jsx)(n.h3,{id:"kind-clusters",children:"Kind clusters"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.a,{href:"https://kind.sigs.k8s.io/",children:"Kind"}),' is a tool for running local Kubernetes clusters using Docker container "nodes."']}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-haskell",metastring:'title="https://github.com/codedownio/sandwich/blob/master/demos/demo-kubernetes-kind/app/Main.hs"',children:'spec :: TopSpec\nspec = describe "Introducing a Kubernetes cluster" $\n  introduceNixContext nixpkgsReleaseDefault $\n    introduceKindClusterViaNix defaultKindClusterOptions $ do\n      it "prints the cluster info" $ do\n        kcc <- getContext kubernetesCluster\n        info [i|Got Kubernetes cluster context: #{kcc}|]\n'})}),"\n",(0,t.jsxs)(n.p,{children:["You can also obtain the ",(0,t.jsx)(n.code,{children:"kind"})," binary from your system PATH:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-haskell",children:'spec :: TopSpec\nspec = describe "Kind cluster from environment" $\n  introduceBinaryViaEnvironment @"kind" $\n    introduceBinaryViaEnvironment @"kubectl" $\n      introduceKindClusterViaEnvironment defaultKindClusterOptions $ do\n        -- Your tests here\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Kind clusters can be configured using ",(0,t.jsx)(n.a,{href:"https://hackage.haskell.org/package/sandwich-contexts-kubernetes/docs/Test-Sandwich-Contexts-Kubernetes-KindCluster.html#t:KindClusterOptions",children:"KindClusterOptions"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Number of nodes"}),": Set via ",(0,t.jsx)(n.a,{href:"https://hackage.haskell.org/package/sandwich-contexts-kubernetes/docs/Test-Sandwich-Contexts-Kubernetes-KindCluster.html#v:kindClusterNumNodes",children:(0,t.jsx)(n.code,{children:"kindClusterNumNodes"})})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Extra flags"}),": Pass additional kind flags via ",(0,t.jsx)(n.a,{href:"https://hackage.haskell.org/package/sandwich-contexts-kubernetes/docs/Test-Sandwich-Contexts-Kubernetes-KindCluster.html#v:kindClusterExtraFlags",children:(0,t.jsx)(n.code,{children:"kindClusterExtraFlags"})})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Container labels"}),": Apply labels to created containers via ",(0,t.jsx)(n.a,{href:"https://hackage.haskell.org/package/sandwich-contexts-kubernetes/docs/Test-Sandwich-Contexts-Kubernetes-KindCluster.html#v:kindClusterContainerLabels",children:(0,t.jsx)(n.code,{children:"kindClusterContainerLabels"})})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Port mappings"}),": Expose cluster ports to the host via ",(0,t.jsx)(n.a,{href:"https://hackage.haskell.org/package/sandwich-contexts-kubernetes/docs/Test-Sandwich-Contexts-Kubernetes-KindCluster.html#v:kindClusterExtraPortMappings",children:(0,t.jsx)(n.code,{children:"kindClusterExtraPortMappings"})})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Mounts"}),": Mount host directories into cluster nodes via ",(0,t.jsx)(n.a,{href:"https://hackage.haskell.org/package/sandwich-contexts-kubernetes/docs/Test-Sandwich-Contexts-Kubernetes-KindCluster.html#v:kindClusterExtraMounts",children:(0,t.jsx)(n.code,{children:"kindClusterExtraMounts"})})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Name prefix"}),": Set cluster name prefix via ",(0,t.jsx)(n.a,{href:"https://hackage.haskell.org/package/sandwich-contexts-kubernetes/docs/Test-Sandwich-Contexts-Kubernetes-KindCluster.html#v:kindClusterNamePrefix",children:(0,t.jsx)(n.code,{children:"kindClusterNamePrefix"})})]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"minikube-clusters",children:"Minikube clusters"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.a,{href:"https://minikube.sigs.k8s.io",children:"Minikube"})," runs a single-node Kubernetes cluster locally, supporting various container runtimes."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-haskell",metastring:'title="https://github.com/codedownio/sandwich/blob/master/demos/demo-kubernetes-minikube/app/Main.hs"',children:'spec :: TopSpec\nspec = describe "Introducing a Kubernetes cluster via Minikube" $\n  introduceNixContext nixpkgsReleaseDefault $\n    introduceMinikubeClusterViaNix defaultMinikubeClusterOptions $ do\n      it "prints the cluster info" $ do\n        kcc <- getContext kubernetesCluster\n        info [i|Got Kubernetes cluster context: #{kcc}|]\n'})}),"\n",(0,t.jsx)(n.p,{children:"Similarly, you can use binaries from your environment:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-haskell",children:'spec :: TopSpec\nspec = describe "Minikube cluster from environment" $\n  introduceBinaryViaEnvironment @"minikube" $\n    introduceBinaryViaEnvironment @"kubectl" $\n      introduceMinikubeClusterViaEnvironment defaultMinikubeClusterOptions $ do\n        -- Your tests here\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Minikube clusters can be configured using ",(0,t.jsx)(n.a,{href:"https://hackage.haskell.org/package/sandwich-contexts-kubernetes/docs/Test-Sandwich-Contexts-Kubernetes-MinikubeCluster.html#t:MinikubeClusterOptions",children:"MinikubeClusterOptions"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Number of nodes"}),": Set via ",(0,t.jsx)(n.a,{href:"https://hackage.haskell.org/package/sandwich-contexts-kubernetes/docs/Test-Sandwich-Contexts-Kubernetes-MinikubeCluster.html#v:minikubeClusterNumNodes",children:(0,t.jsx)(n.code,{children:"minikubeClusterNumNodes"})})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Extra flags"}),": Pass additional minikube flags via ",(0,t.jsx)(n.a,{href:"https://hackage.haskell.org/package/sandwich-contexts-kubernetes/docs/Test-Sandwich-Contexts-Kubernetes-MinikubeCluster.html#v:minikubeClusterExtraFlags",children:(0,t.jsx)(n.code,{children:"minikubeClusterExtraFlags"})})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Name prefix"}),": Set cluster name prefix via ",(0,t.jsx)(n.a,{href:"https://hackage.haskell.org/package/sandwich-contexts-kubernetes/docs/Test-Sandwich-Contexts-Kubernetes-MinikubeCluster.html#v:minikubeClusterNamePrefix",children:(0,t.jsx)(n.code,{children:"minikubeClusterNamePrefix"})})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Driver"}),": Choose container runtime via ",(0,t.jsx)(n.a,{href:"https://hackage.haskell.org/package/sandwich-contexts-kubernetes/docs/Test-Sandwich-Contexts-Kubernetes-MinikubeCluster.html#v:minikubeClusterDriver",children:(0,t.jsx)(n.code,{children:"minikubeClusterDriver"})})," (docker, podman, etc.)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"CPUs"}),": Set CPU allocation via ",(0,t.jsx)(n.a,{href:"https://hackage.haskell.org/package/sandwich-contexts-kubernetes/docs/Test-Sandwich-Contexts-Kubernetes-MinikubeCluster.html#v:minikubeClusterCpus",children:(0,t.jsx)(n.code,{children:"minikubeClusterCpus"})})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Memory"}),": Set memory allocation via ",(0,t.jsx)(n.a,{href:"https://hackage.haskell.org/package/sandwich-contexts-kubernetes/docs/Test-Sandwich-Contexts-Kubernetes-MinikubeCluster.html#v:minikubeClusterMemory",children:(0,t.jsx)(n.code,{children:"minikubeClusterMemory"})})]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"working-with-clusters",children:"Working with clusters"}),"\n",(0,t.jsx)(n.p,{children:"Once you have a cluster, you can access its context:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-haskell",children:'it "uses cluster context" $ do\n  kcc <- getContext kubernetesCluster\n  info [i|Cluster name: #{kubernetesClusterName kcc}|]\n  info [i|Kubeconfig path: #{kubernetesClusterKubeConfigPath kcc}|]\n  info [i|Number of nodes: #{kubernetesClusterNumNodes kcc}|]\n'})}),"\n",(0,t.jsx)(n.h3,{id:"running-kubectl-commands",children:"Running kubectl commands"}),"\n",(0,t.jsx)(n.p,{children:"The library provides utilities for running kubectl commands with the correct configuration:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-haskell",children:'it "runs kubectl commands" $ do\n  (kubectlBinary, env) <- askKubectlArgs\n  pods <- readCreateProcessWithLogging\n    ((proc kubectlBinary ["get", "pods", "-A"]) { env = Just env }) ""\n  info [i|Cluster pods: #{pods}|]\n'})}),"\n",(0,t.jsx)(n.h3,{id:"waiting-for-resources",children:"Waiting for resources"}),"\n",(0,t.jsx)(n.p,{children:"The library includes utilities for waiting for Kubernetes resources to be ready:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-haskell",children:'it "waits for resources" $ do\n  -- Wait for pods to exist\n  waitForPodsToExist "default" (LabelSelector [("app", "my-app")])\n\n  -- Wait for pods to be ready\n  waitForPodsToBeReady "default" (LabelSelector [("app", "my-app")])\n\n  -- Wait for service endpoints\n  waitForServiceEndpointsToExist "default" "my-service"\n'})}),"\n",(0,t.jsx)(n.h2,{id:"image-management",children:"Image management"}),"\n",(0,t.jsxs)(n.p,{children:["The library provides ",(0,t.jsx)(n.a,{href:"https://hackage-content.haskell.org/package/sandwich-contexts-kubernetes/docs/Test-Sandwich-Contexts-Kubernetes-Images.html",children:"image management"})," for both cluster types. You can load an image onto the cluster directly from your local Docker/Podman system, or from a tarball."]}),"\n",(0,t.jsxs)(n.p,{children:["An important thing to understand here is that an image name once it's loaded onto the cluster may not be the same as its local name. The ",(0,t.jsx)(n.a,{href:"https://hackage-content.haskell.org/package/sandwich-contexts-kubernetes/docs/Test-Sandwich-Contexts-Kubernetes-Images.html#v:loadImage",children:"loadImage"})," function will return the cluster name of the image. This is the name you should use if you proceed to e.g. create a Pod using this image."]}),"\n",(0,t.jsx)(n.h3,{id:"loading-images",children:"Loading images"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-haskell",children:'it "loads images into cluster" $ do\n  -- Load from Docker\n  busyBoxImage <- loadImage (ImageLoadSpecDocker "busybox:latest" IfNotPresent)\n\n  -- Load from Podman\n  nginxImage <- loadImage (ImageLoadSpecPodman "nginx:latest" Always)\n\n  -- Load from tarball\n  tarPath <- buildNixCallPackageDerivation myImageDerivation\n  tarballImage <- loadImage (ImageLoadSpecTarball tarPath)\n\n  -- Use these images\n'})}),"\n",(0,t.jsx)(n.h3,{id:"checking-loaded-images",children:"Checking loaded images"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-haskell",children:'it "checks available images" $ do\n  images <- getLoadedImages\n  forM_ images $ \\image -> info [i|Available image: #{image}|]\n\n  hasImage <- clusterContainsImage "busybox:latest"\n  hasImage `shouldBe` True\n'})}),"\n",(0,t.jsx)(n.h2,{id:"service-forwarding-and-port-forwarding",children:"Service forwarding and port forwarding"}),"\n",(0,t.jsx)(n.h3,{id:"service-forwarding",children:"Service forwarding"}),"\n",(0,t.jsx)(n.p,{children:"Forward Kubernetes services to local URLs:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-haskell",children:'it "forwards a service" $ do\n  withForwardKubernetesService "default" "my-service" $ \\serviceUrl -> do\n    info [i|Service available at: #{serviceUrl}|]\n    -- Make requests to the service\n'})}),"\n",(0,t.jsx)(n.h3,{id:"port-forwarding",children:"Port forwarding"}),"\n",(0,t.jsx)(n.p,{children:"Forward specific pods or services to local ports:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-haskell",children:'it "port forwards to a pod" $ do\n  withKubectlPortForward "default" "pod/my-pod" "8080:80" $ \\localPort -> do\n    info [i|Pod forwarded to local port: #{localPort}|]\n    -- Connect to localhost:localPort\n'})}),"\n",(0,t.jsx)(n.h2,{id:"namespaces",children:"Namespaces"}),"\n",(0,t.jsxs)(n.p,{children:["Create and destroy ",(0,t.jsx)(n.a,{href:"https://hackage-content.haskell.org/package/sandwich-contexts-kubernetes/docs/Test-Sandwich-Contexts-Kubernetes-Namespace.html",children:"Kubernetes namespaces"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-haskell",children:'spec :: TopSpec\nspec = introduceKindClusterViaNix defaultKindClusterOptions $\n  withKubernetesNamespace "my-test-namespace" $ do\n    it "runs in custom namespace" $ do\n      -- Tests run within the "my-test-namespace" namespace\n'})}),"\n",(0,t.jsx)(n.h2,{id:"minio-integration",children:"MinIO integration"}),"\n",(0,t.jsxs)(n.p,{children:["The library includes built-in support for deploying ",(0,t.jsx)(n.a,{href:"https://www.min.io/",children:"MinIO"})," object storage using the ",(0,t.jsx)(n.a,{href:"https://docs.min.io/enterprise/aistor-object-store/installation/kubernetes/install/",children:"operator"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["Once you deploy the operator, you can create a MinIO server using the ",(0,t.jsx)(n.a,{href:"https://hackage-content.haskell.org/package/sandwich-contexts-kubernetes/docs/Test-Sandwich-Contexts-Kubernetes-MinioS3Server.html#v:introduceK8SMinioS3Server",children:"introduceK8SMinioS3Server"})," family of functions."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-haskell",metastring:'title="https://github.com/codedownio/sandwich/blob/master/demos/demo-kubernetes-kind/app/Main.hs"',children:'spec :: TopSpec\nspec = introduceKindClusterViaNix defaultKindClusterOptions $\n  introduceBinaryViaNixPackage @"kubectl" "kubectl" $\n    introduceMinioOperator defaultMinioOperatorOptions $\n      withKubernetesNamespace "minio-test" $\n        introduceK8SMinioS3Server (defaultMinioS3ServerOptions "minio-test") $ do\n          it "has MinIO S3 server" $ do\n            server <- getContext testS3Server\n            info [i|Got S3 server: #{server}|]\n'})}),"\n",(0,t.jsx)(n.h2,{id:"logging",children:"Logging"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.a,{href:"https://hackage-content.haskell.org/package/sandwich-contexts-kubernetes/docs/Test-Sandwich-Contexts-Kubernetes.html#v:withKubectlLogs",children:"withKubectlLogs"})," function will run a ",(0,t.jsx)(n.code,{children:"kubectl logs"})," process, placing the logs in a file in the current test node directory."]}),"\n",(0,t.jsx)(n.p,{children:"Note that this will stop working if the pod you're talking to goes away (even if you do it against a service). If this happens, a rerun of the command is needed to resume log forwarding."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-haskell",children:'it "gets pod logs" $ do\n  logs <- kubectlLogs "default" "my-pod" []\n  info [i|Pod logs: #{logs}|]\n\n  -- Follow logs in real-time\n  withKubectlLogs "default" "my-pod" ["-f"] $ \\logHandle -> do\n    -- Process streaming logs\n'})})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},6113:(e,n,s)=>{s.d(n,{R:()=>a,x:()=>o});var t=s(758);const i={},r=t.createContext(i);function a(e){const n=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);