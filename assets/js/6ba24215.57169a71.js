"use strict";(self.webpackChunksandwich_site=self.webpackChunksandwich_site||[]).push([[98],{7161:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>r,contentTitle:()=>l,default:()=>h,frontMatter:()=>o,metadata:()=>a,toc:()=>d});var n=s(6070),i=s(6113);s(4125);const o={id:"discovery",title:"Test Discovery",sidebar_label:"Test Discovery"},l=void 0,a={id:"discovery",title:"Test Discovery",description:"Test discovery is the process of automatically finding test files, so you don't need to manually manage your imports and write out top-level test trees.",source:"@site/docs/discovery.md",sourceDirName:".",slug:"/discovery",permalink:"/sandwich/docs/discovery",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/edit/master/website/docs/discovery.md",tags:[],version:"current",frontMatter:{id:"discovery",title:"Test Discovery",sidebar_label:"Test Discovery"},sidebar:"docs",previous:{title:"Command line",permalink:"/sandwich/docs/command_line"},next:{title:"Terminal UI Formatter",permalink:"/sandwich/docs/formatters/tui"}},r={},d=[{value:"The basic setup",id:"the-basic-setup",level:2},{value:"Running individual test modules",id:"running-individual-test-modules",level:2},{value:"Main function autodetection",id:"main-function-autodetection",level:2}];function c(e){const t={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.p,{children:"Test discovery is the process of automatically finding test files, so you don't need to manually manage your imports and write out top-level test trees."}),"\n",(0,n.jsxs)(t.p,{children:["For the purposes of this discussion, let's assume a somewhat complex test suite with different kinds of tests, laid out on disk like the following. The key point is that different groups of tests may require different contexts: for example, ",(0,n.jsx)(t.code,{children:"UnitTests"})," have no dependencies but ",(0,n.jsx)(t.code,{children:"SeleniumTests"})," require ",(0,n.jsx)(t.a,{href:"./extensions/sandwich-webdriver",children:"Selenium"})," context."]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-bash",children:"<project root>\n\u2514\u2500 tests\n   \u251c\u2500 Main.hs\n   \u251c\u2500 UnitTests.hs\n   \u251c\u2500 UnitTests\n   \u2502  \u251c\u2500 UnitTests1.hs\n   \u2502  \u2514\u2500 UnitTests2.hs\n   \u251c\u2500 SeleniumTests.hs\n   \u2514\u2500 SeleniumTests\n      \u251c\u2500 SeleniumTests1.hs\n      \u2514\u2500 SeleniumTests2.hs\n"})}),"\n",(0,n.jsxs)(t.p,{children:["In ",(0,n.jsx)(t.code,{children:"Main.hs"}),", we want to automatically generate something like this:"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-haskell",children:'module Main where\n\nimport Test.Sandwich\nimport Test.Sandwich.WebDriver\n\nimport qualified UnitTests.UnitTests1\nimport qualified UnitTests.UnitTests2\nimport qualified SeleniumTests.SeleniumTests1\nimport qualified SeleniumTests.SeleniumTests2\n\ntests = do\n  describe "Unit tests" $ do\n    UnitTests1.tests\n    UnitTests2.tests\n\n  introduceWebDriver defaultWdOptions $\n    describe "Selenium tests" $ do\n      SeleniumTests1.tests\n      SeleniumTests2.tests\n'})}),"\n",(0,n.jsx)(t.h2,{id:"the-basic-setup",children:"The basic setup"}),"\n",(0,n.jsxs)(t.p,{children:["Autogenerating the tests in a given module requires two pieces of code in that module: 1) A CPP pragma to generate the imports, and 2) a Template Haskell call to generate the test tree. (Unfortunately it can't be done solely with Template Haskell, because ",(0,n.jsx)(t.a,{href:"https://gitlab.haskell.org/ghc/ghc/-/issues/1475",children:"TH cannot generate imports"}),".)"]}),"\n",(0,n.jsxs)(t.p,{children:["To autogenerate tests for the example above, we'll apply autodetection separately in ",(0,n.jsx)(t.code,{children:"UnitTests.hs"})," and ",(0,n.jsx)(t.code,{children:"SeleniumTests.hs"}),". You can follow along with the full example ",(0,n.jsx)(t.a,{href:"https://github.com/codedownio/sandwich/tree/master/demos/demo-discover",children:"here"}),"."]}),"\n",(0,n.jsxs)(t.p,{children:["In the code below, the ",(0,n.jsx)(t.code,{children:"OPTIONS_GHC"})," pragma invokes the ",(0,n.jsx)(t.code,{children:"sandwich-discover"})," executable, which searches for modules ",(0,n.jsx)(t.em,{children:"underneath the current module"})," (i.e., matching ",(0,n.jsx)(t.code,{children:"SeleniumTests.*"}),"). Then it inserts the imports wherever it finds the special ",(0,n.jsx)(t.code,{children:"#insert_test_imports"})," token."]}),"\n",(0,n.jsxs)(t.p,{children:["Finally, the code below calls ",(0,n.jsx)(t.code,{children:"getSpecFromFolder"})," in a TH spec to generate the actual test tree."]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-haskell",metastring:'title="SeleniumTests.hs"',children:'{-# OPTIONS_GHC -F -pgmF sandwich-discover #-}\n{-# LANGUAGE CPP #-}\n{-# LANGUAGE TemplateHaskell #-}\n\nmodule SeleniumTests where\n\nimport Test.Sandwich\nimport Test.Sandwich.WebDriver\n\n#insert_test_imports\n\ntests :: TopSpec\ntests = describe "Selenium tests" $ introduceWebDriver defaultWdOptions $ do\n  $(getSpecFromFolder defaultGetSpecFromFolderOptions)\n\nmain :: IO ()\nmain = runSandwichWithCommandLineArgs defaultOptions tests\n'})}),"\n",(0,n.jsxs)(t.p,{children:["Once we write similar boilerplate in ",(0,n.jsx)(t.code,{children:"UnitTests.hs"}),", we can pull both sub-trees together into the main top-level tree below."]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-haskell",metastring:'title="Main.hs"',children:'module Main (Main.main) where\n\nimport qualified SeleniumTests\nimport qualified UnitTests\n\ndiscoverDemo :: TopSpec\ndiscoverDemo = describe "Discover" $ do\n  UnitTests.tests\n  SeleniumTests.tests\n'})}),"\n",(0,n.jsx)(t.h2,{id:"running-individual-test-modules",children:"Running individual test modules"}),"\n",(0,n.jsxs)(t.p,{children:["Having set up test autodetection as above, we can now take advantage of the ability to run individual test modules. When you run with ",(0,n.jsx)(t.code,{children:"--list-tests"}),", you'll see a list of special flags you can pass. When you pass any of these flags, Sandwich will run only that test module."]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-bash",children:"> stack run demo-discover -- --list-tests\n\nAvailable options:\n  --selenium-tests         SeleniumTests\n  --selenium-tests1        SeleniumTests.SeleniumTests1\n  --selenium-tests2        SeleniumTests.SeleniumTests2\n  --unit-tests             UnitTests\n  --unit-tests1            UnitTests.UnitTests1\n  --unit-tests2            UnitTests.UnitTests2\n  -h,--help                Show this help text\n"})}),"\n",(0,n.jsx)(t.admonition,{type:"note",children:(0,n.jsxs)(t.p,{children:["You can always run individual test subtrees by simply passing ",(0,n.jsx)(t.code,{children:'--filter "some filter string"'})," with an appropriate filter string. However, this will filter the tree to any nodes that match the filter string, so it may not be as convenient to exactly match the subtree corresponding to a single module."]})}),"\n",(0,n.jsx)(t.h2,{id:"main-function-autodetection",children:"Main function autodetection"}),"\n",(0,n.jsxs)(t.p,{children:["Sometimes you want to include a ",(0,n.jsx)(t.code,{children:"main"})," function in an individual test module. These main functions can be convenient when you want to iterate on a single test module within a GHCi session, for example."]}),"\n",(0,n.jsxs)(t.p,{children:["Sandwich can discover the presence of these ",(0,n.jsx)(t.code,{children:"main"})," functions and give you the ability to run them using the individual module flag. It does this using some ",(0,n.jsx)(t.a,{href:"https://hackage.haskell.org/package/haskell-src-exts",children:"magic"}),"."]}),"\n",(0,n.jsxs)(t.p,{children:["If this has happened, Sandwich will indicate it by putting an asterisk next to the module name. For example, if ",(0,n.jsx)(t.code,{children:"UnitTests2.hs"})," had its own main function inside, you would see the following."]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-bash",children:"> stack run demo-discover -- --list-tests\n\nAvailable options:\n  --selenium-tests         SeleniumTests\n  --selenium-tests1        SeleniumTests.SeleniumTests1\n  --selenium-tests2        SeleniumTests.SeleniumTests2\n  --unit-tests             UnitTests\n  --unit-tests1            UnitTests.UnitTests1\n  --unit-tests2            UnitTests.UnitTests2*\n  -h,--help                Show this help text\n"})}),"\n",(0,n.jsxs)(t.p,{children:["Thus, passing ",(0,n.jsx)(t.code,{children:"--unit-tests2"})," would result in that file's ",(0,n.jsx)(t.code,{children:"main"})," function being invoked, rather than the normal one in ",(0,n.jsx)(t.code,{children:"Main.hs"}),"."]})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(c,{...e})}):c(e)}},6113:(e,t,s)=>{s.d(t,{R:()=>l,x:()=>a});var n=s(758);const i={},o=n.createContext(i);function l(e){const t=n.useContext(o);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),n.createElement(o.Provider,{value:t},e.children)}}}]);